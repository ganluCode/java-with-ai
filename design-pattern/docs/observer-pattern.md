# 观察者模式 (Observer Pattern)

## 1. 模式简介

观察者模式是一种行为设计模式，它定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。

### 1.1 别名
- 发布-订阅模式 (Publish-Subscribe Pattern)
- 模型-视图模式 (Model-View Pattern)
- 源-监听器模式 (Source-Listener Pattern)
- 依赖者模式 (Dependents Pattern)

### 1.2 意图
定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

### 1.3 核心思想
- 建立一种对象间的依赖关系，一个对象发生改变将自动通知其他对象
- 提供了一种广播机制，让对象状态改变时能通知所有观察者
- 解耦了主题和观察者，使它们可以独立变化

## 2. 适用场景

- 当一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时
- 当一个对象必须通知其他对象，而不能假定其他对象是谁时（避免紧耦合）
- 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面时

## 3. 结构说明

### 3.1 主要角色

1. **Subject（抽象主题）**
   - 提供了用于添加、删除和通知观察者的接口
   - 维护观察者列表

2. **ConcreteSubject（具体主题）**
   - 实现抽象主题接口
   - 存储具体状态
   - 当状态改变时，向观察者发出通知

3. **Observer（抽象观察者）**
   - 定义一个更新接口，用于接收主题的通知

4. **ConcreteObserver（具体观察者）**
   - 实现抽象观察者接口
   - 维护指向具体主题的引用
   - 存储与主题状态一致的状态
   - 实现更新接口以保持自身状态与主题状态一致

## 4. 优缺点

### 4.1 优点
- **降低耦合度**：主题与观察者之间建立了一个抽象的耦合关系
- **支持广播通信**：主题可以通知所有注册的观察者
- **符合开闭原则**：增加新的观察者无需修改主题代码
- **运行时建立对象关系**：可以在运行时动态地建立和删除观察者

### 4.2 缺点
- **可能导致内存泄漏**：如果观察者没有正确地从主题中注销，可能会导致内存泄漏
- **通知效率问题**：广播通信可能会影响性能，特别是在观察者数量较多时
- **循环依赖问题**：可能导致系统崩溃或行为异常
- **意外的更新**：观察者无法知道主题的变化原因

## 5. 实际应用场景

1. **GUI事件处理**：按钮点击、鼠标移动等事件处理
2. **消息订阅系统**：新闻订阅、RSS订阅等
3. **MVC架构**：模型与视图之间的通信
4. **实时数据更新**：股票行情、天气预报等实时数据展示
5. **游戏开发**：游戏状态变更通知
6. **分布式系统**：服务状态变更通知

## 6. 常见问题与解决方案

### 6.1 内存泄漏问题
- **问题**：观察者没有正确从主题中注销，导致无法被垃圾回收
- **解决方案**：
  1. 使用弱引用(WeakReference)维护观察者列表
  2. 提供显式的注销方法
  3. 在观察者销毁时自动注销

### 6.2 通知顺序问题
- **问题**：观察者的通知顺序可能影响系统行为
- **解决方案**：
  1. 使用优先级队列维护观察者
  2. 明确文档说明通知顺序不保证
  3. 提供有序通知的扩展版本

### 6.3 异常处理问题
- **问题**：一个观察者的异常可能影响其他观察者的执行
- **解决方案**：
  1. 在通知循环中捕获并处理异常
  2. 记录异常日志但继续通知其他观察者
  3. 提供异步通知机制

### 6.4 性能问题
- **问题**：观察者数量过多时通知效率低下
- **解决方案**：
  1. 使用分批通知机制
  2. 提供条件过滤功能
  3. 实现异步通知模式

## 7. Java内置观察者模式

Java在java.util包中提供了Observable类和Observer接口，但在Java 9中已被标记为废弃。

### 7.1 使用示例
```java
import java.util.Observable;
import java.util.Observer;

// 被观察者
class NewsAgency extends Observable {
    private String news;
    
    public void setNews(String news) {
        this.news = news;
        setChanged(); // 标记状态已改变
        notifyObservers(news); // 通知所有观察者
    }
}

// 观察者
class NewsChannel implements Observer {
    private String news;
    
    @Override
    public void update(Observable agency, Object news) {
        this.news = (String) news;
        System.out.println("News Channel received: " + news);
    }
}
```

### 7.2 现代替代方案
1. **JavaBeans**：PropertyChangeListener机制
2. **事件监听器**：Swing/AWT中的事件处理机制
3. **RxJava**：响应式编程库
4. **Spring Events**：Spring框架的事件机制

## 8. 增强特性实现

### 8.1 内存泄漏防护
使用WeakReference维护观察者列表，避免因忘记注销观察者而导致的内存泄漏。

### 8.2 异步通知机制
通过线程池实现异步通知，避免长时间运行的观察者阻塞主线程。

### 8.3 优先级通知
支持按优先级顺序通知观察者，确保重要观察者优先处理。

### 8.4 条件过滤
提供过滤机制，只在满足特定条件时才通知观察者，提高效率。

## 9. 总结

观察者模式是面向对象设计中的重要模式之一，它提供了一种优雅的方式来处理对象间的一对多依赖关系。通过合理的使用观察者模式，我们可以构建出松耦合、易扩展的系统。在实际应用中，我们需要根据具体需求选择合适的实现方式，并注意处理好内存管理、异常处理和性能优化等问题。